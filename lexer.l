%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "parser.tab.h"  /* Generated by Bison after running bison -d parser.y */

extern int yylval_int;   /* We can store integer literals here, declared in parser.y */
extern char* yylval_str; /* We can store identifier names here, declared in parser.y */

void yyerror(const char *s);
%}

%%

/* KEYWORDS & IDENTIFIERS */
"function"               { return FUNCTION_TOKEN; }
"if"                     { return IF_TOKEN; }
"else"                   { return ELSE_TOKEN; }
"for"                    { return FOR_TOKEN; }
"return"                 { return RETURN_TOKEN; }
"true"                   { return TRUE_TOKEN; }
"false"                  { return FALSE_TOKEN; }

[a-zA-Z_][a-zA-Z0-9_]*   {
    /* It's an identifier (unless it matches a keyword above) */
    yylval_str = strdup(yytext);
    return IDENTIFIER_TOKEN;
}

/* INTEGER LITERALS */
[0-9]+                   {
    yylval_int = atoi(yytext);
    return INT_LITERAL_TOKEN;
}

/* INVALID IDENTIFIERS (e.g., 1n) */
[0-9]+[a-zA-Z_][a-zA-Z0-9_]*  {
    fprintf(stderr, "Lexical Error: Invalid identifier '%s'\n", yytext);
    /* Simple panic-mode recovery: skip this 'token' */
}

/* OPERATORS & DELIMITERS */
"=="                     { return EQUAL_TOKEN; }
"!="                     { return NOT_EQUAL_TOKEN; }
"<="                     { return LESS_EQUAL_TOKEN; }
">="                     { return GREATER_EQUAL_TOKEN; }
"&&"                     { return AND_TOKEN; }
"||"                     { return OR_TOKEN; }
"++"                     { return INCREMENT_TOKEN; }
"--"                     { return DECREMENT_TOKEN; }
"="                      { return ASSIGN_TOKEN; }
"<"                      { return LESS_TOKEN; }
">"                      { return GREATER_TOKEN; }
"+"                      { return PLUS_TOKEN; }
"-"                      { return MINUS_TOKEN; }
"*"                      { return MULTIPLY_TOKEN; }
"/"                      { return DIVIDE_TOKEN; }
"%"                      { return MODULO_TOKEN; }
"("                      { return LEFT_PAREN_TOKEN; }
")"                      { return RIGHT_PAREN_TOKEN; }
"{"                      { return LEFT_BRACE_TOKEN; }
"}"                      { return RIGHT_BRACE_TOKEN; }
";"                      { return SEMICOLON_TOKEN; }
","                      { return COMMA_TOKEN; }

/* WHITESPACE (ignored) */
[ \t\r\n]+               { /* skip */ }

/* ANYTHING ELSE -> ERROR */
.                        {
    fprintf(stderr, "Lexical Error: Unrecognized character '%s'\n", yytext);
    /* Simple panic-mode recovery: skip this character */
}

%%

int main(int argc, char **argv) {
    if (argc > 1) {
        FILE *file = fopen(argv[1], "r");
        if (!file) {
            fprintf(stderr, "Cannot open file: %s\n", argv[1]);
            exit(1);
        }
        yyin = file;
    }
    /* Invoke the parser (defined in parser.y) */
    yyparse();
    return 0;
}

void yyerror(const char *s) {
    fprintf(stderr, "Error: %s\n", s);
}
